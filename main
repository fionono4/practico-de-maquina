#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "turnos.h"
#include "servicio.h"
#include "lista turnos.h"
typedef struct
{
    char* fturno[5];
    char* hora[5];
    int estado;
} fecha;

fecha f[1464];
int cantd=0; //se inicializa la cantidad de dias mostrados
servicio aux_servicio[15];
char *randstring(size_t length)
{
    int n;
    static char charset[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789,.-#'?!";
    char *randomString = NULL;

    if (length)
    {
        randomString = malloc(sizeof(char) * (length +1));

        if (randomString)
        {
            for (n = 0; n < length; n++)
            {
                int key = rand() % (int)(sizeof(charset) -1);
                randomString[n] = charset[key];
            }

            randomString[length] = '\0';
        }
    }

    return randomString;
}
void precarga_calendario(fecha f[])
{
    int i;
    FILE *fp=fopen("precarga.txt", "r");
    if(fopen("precarga.txt","r")==NULL)
    {
        printf("no es posible abrir el archivo\n");
        exit(1);
    }
    else
    {
        for (i=0; i<1464; i++)
        {
            fscanf(fp, "%s \n", &f[i].fturno);
            fscanf(fp, "%s \n", &f[i].hora);
            fscanf(fp, "%d \n", &f[i].estado);
        }
    }
}
void muestra_calendario(fecha f[])
{
    int i;
    for (i=0; i<1464; i++)
    {
        printf("%s \n", f[i].fturno);
        printf("%s \n", f[i].hora);
        printf("%d \n", f[i].estado);
    }
}

int busca_fecha(fecha f[], char a[]){ //función que retorna la posición en el arreglo de la fecha pasada por parámetro
    int i;
    for (i=0; i<1464; i++){
        if (strcmp(f[i].fturno, a)==1){
            return i;
            exit(1);
        }
        else return -1;
    }
}
void muestra_dias_disponibles(fecha f[], int *a)  //a registra cuántos dias se mostraron, similar a cant. se pasa por dirección para actualizar la variable cada vez que se invoca
{
    int i;
    printf("Dias disponibles: \n");
    for (i=0; i<28; i++)
    {
        if (f[i].estado==0)
        {
            printf("Turno: %d \n", i);
            printf("Dia: %s \n", f[i].fturno);
            printf("Hora: %s \n", f[i].hora);
        }
    }
    *a=*a+28;
}

int seleccion_servicio(turno *t)
{
    int serv;
    int i;
    printf("Seleccione un servicio: \n");
    for (i=0; i<15; i++)
    {
        printf("%d: %s \n",i, aux_servicio[i].descripcion);
        printf("Precio: %f \n", aux_servicio[i].precio);
        printf("Descuento: %d \n", aux_servicio[i].descuento);
    }
    scanf("%d", &serv);
    getchar();
    set_servicios(t, serv);
    return serv;
}

turno carga_turno()
{
    turno t;
    char cliente[50], fechat[5], idturno[5];
    int estado,servicios, fpago, diat, guarda, rep=0; //diat es el número de turno elegido
    float total, subtotal;

    while(rep==0){ //mientras que NO confirme
        strcpy(idturno, randstring(5)); //inicializa el id turno con un string aleatorio de letras y numeros
        set_idturno(&t, idturno);

        muestra_dias_disponibles(f, &cantd); //ofrece al usuario los dias seleccionables para turnos
        scanf("%d", &diat);
        getchar();
        strcpy(fechat, f[diat].fturno);
        set_fecha(&t, fechat); //se guarda la fecha seleccionada
        printf("Fecha: %s \n", get_fecha(t));
        printf("Hora: %s \n", f[diat].hora);

        printf("Ingrese el nombre de cliente \n");
        scanf("%[^\n]s", cliente);
        getchar();
        set_cliente(&t, cliente);

        servicios=seleccion_servicio(&t); //ofrece los servicios disponibles al usuario, y guarda el que selecciona
        set_subtotal(&t, get_precio(aux_servicio[servicios]));
        subtotal=get_precio(aux_servicio[servicios]);
        if (get_descuento(aux_servicio[servicios])==0){
            total=get_precio(aux_servicio[servicios]);
        }
            else total=get_precio(aux_servicio[servicios])*(get_descuento(aux_servicio[servicios]))/100; //calcula el descuento si lo tiene

        printf("Ingrese la forma de pago 1: Debito, 2: Credito 3: Efectivo  4:QR \n");
        scanf("%d", &fpago);
        getchar();
        set_fpago(&t, fpago);

        printf("Subtotal: %f \n", subtotal);
        printf("Total con descuento: %f \n", total);
        printf("Desea confimar el turno? 1: si, 0: no \n");
        scanf("%d", &guarda);
        getchar();
        if(guarda==1){
            rep=1;
            f[diat].estado=guarda; //guarda el estado del turno

        }

    }
    return t;
}
//a) Cargar un turno en la lista por teclado. Debe respetar la posición , ya que la posición es el código del mismo.
//Mostrar las opciones de turno disponible para la semana antes de agendar el mismo.
//Considere que el cálculo del total a pagar debe ser realizado al final de la carga del turno y se debe mostrar el
//subtotal y total para confirmar el turno.

void muestra_turno(turno t)
{
    int i;
    printf("ID turno: %s \n", get_idturno(t));
    printf("Fecha: %s \n", get_fecha(t));
    printf("Nombre del cliente: %s \n", get_cliente(t));
    for (i=0; i<15; i++){
      if (get_servicios(t, i)==1){ //si el servicio está seleccionado
        printf("Servicio: %d:", i);
        printf("%s \n", get_descripcion(aux_servicio[i]));
      }

    }
    printf("Subtotal: %f \n", get_subtotal(t));
    printf("Forma de pago: %d \n", get_fpago(t)); //switch
}
lista carga_lista(){
    lista l;
    inicio(&l);
    turno t=carga_turno();
    turno p;
    reset(&l);
    if (isEmpty(l)==1){
        insertar(&l, t); //help
    }
        else {
            forwards(&l);
            p=copia(l);
            while (!isOos(l)){
                if (busca_fecha(f, get_fecha(p))>busca_fecha(f, get_fecha(t))){
                       insertar(&l, t);
                }
                    else forwards(&l);
                     p=copia(l);
            }
    }
    reset(&l);
    //condicional
return l;
}

// d) Mostrar todos los turnos de una semana ordenados por dia
void muestra_turnos_ordenados_fecha(lista l){
    reset(&l);
    turno t, u;
    while (!isOos(l)){
        t=copia(l);
        forwards(&l);
        u=copia(l);
         if (busca_fecha(f, get_fecha(t))<busca_fecha(f, get_fecha(u))){ //si la fecha de t está en una posición anterior a la de u
            muestra_turno(t);
         }
            else muestra_turno(u);
    }
}

//e) Mostrar los turnos por nombre, paginar la muestra de los datos
void muestra_turnos_ordenados_nombre(lista l){

    reset(&l);
    turno t, u;
    while (!isOos(l)){
        t=copia(l);
        forwards(&l);
        u=copia(l);
         if(get_idturno(t)[0]<get_idturno(u)[0]){
            muestra_turno(t);
         }
            else muestra_turno(u);
    }
}

// j) Modificar la forma de pago de un turno según su idturno
void modifica_turno (turno *t, char id[], char fp){
    if (strcmp(get_idturno(*t), id)==1){
        set_fpago(&t, fp);
    }
}

void modifica_turno2(lista *l, char id[], char fp){
    turno t;
    reset(&l);
    while (!isOos){
        if (strcmp(get_idturno(copia(*l)), id)==1){
            t=copia(*l);
            set_fpago(&t, fp);
            insertar(&l, t);
        }
            else forwards(&l);
    }
}

// k) Anular un turno por idturno, esta función copia en un archivo los datos del turno borrado antes de eliminarlo. Los datos deben ser legibles desde un editor de texto.
void anula_turno(lista *l, char id[]){
  FILE *fp=fopen("backup.txt", "w");
  int i;
  if (fopen("backup.txt", "w")==NULL){
    printf("no se puede abrir el archivo \n");
    exit(1);
  }

  reset(&l);
  while(!isOos){
    if (strcmp(get_idturno(copia(*l)), id)==1){
            while (!feof(fp)){
                fscanf(fp, "%s \n", get_idturno(copia(*l)));
                fscanf(fp, "%[^\n]s \n", get_cliente(copia(*l)));
                fscanf(fp, "%s \n", get_fecha(copia(*l)));
                fscanf(fp, "%d \n", get_fpago(copia(*l)));
                fscanf(fp, "%f \n", get_subtotal(copia(*l)));
                for (i=0; i<15; i++){
                fscanf(fp, "%d \n", get_servicios(copia(*l), i));
                }


    }
    fclose(fp);
    suprimir(&l);
    }
  }
}
int main()
{
    lista l;
    precarga_calendario(f);
    precarga_servicio(aux_servicio);
    l=carga_lista();
    muestra_turno(copia(l));
}
